import argparse
import os
import sys
import subprocess
import re
import struct

# --- UI Helpers ---
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

def print_banner():
    banner = rf"""{Colors.CYAN}{Colors.BOLD}    ___                      ______                
   /  _/________  ____      / ____/___  ________  
   / / / ___/ __ \/ __ \    / /   / __ \/ ___/ _ \ 
 _/ / / /  / /_/ / / / /   / /___/ /_/ / /  /  __/ 
/___//_/   \____/_/ /_/    \____/\\____/_/  \\___/  
                                                    
{Colors.ENDC}{Colors.BLUE}    MIPSduino Assembler v2.0{Colors.ENDC}
    {Colors.CYAN}Powered by MicroCoreASM Hardware Integration{Colors.ENDC}"""
    print(banner)
    sys.stdout.flush()
 
def print_success(msg):
    print(f"{Colors.GREEN}✔ {msg}{Colors.ENDC}")
    sys.stdout.flush()

def print_error(msg):
    print(f"{Colors.RED}✘ Error: {msg}{Colors.ENDC}", file=sys.stderr)
    sys.stderr.flush()

def print_info(msg):
    print(f"{Colors.BLUE}ℹ {msg}{Colors.ENDC}")
    sys.stdout.flush()

def print_warning(msg):
    print(f"{Colors.YELLOW}⚠ {msg}{Colors.ENDC}")
    sys.stdout.flush()

# --- Configuration ---
def get_mars_jar_path():
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
        return os.path.join(base_path, "Mars.jar")
    else:
        # Try local, then parent, then root
        paths = [
            os.path.abspath(os.path.join(os.path.dirname(__file__), "Mars.jar")),
            os.path.abspath(os.path.join(os.path.dirname(__file__), "../../Mars.jar")),
            os.path.abspath("Mars.jar")
        ]
        for p in paths:
            if os.path.exists(p):
                return p
        return "Mars.jar"

MARS_JAR_PATH = get_mars_jar_path()

def check_java():
    try:
        subprocess.check_call(["java", "-version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return True
    except (FileNotFoundError, subprocess.CalledProcessError):
        return False

# --- Core Logic ---

def assemble_to_hex(asm_file, output_hex):
    if not os.path.exists(MARS_JAR_PATH):
        print_error(f"Mars.jar not found at {MARS_JAR_PATH}")
        return False

    cmd = ["java", "-jar", MARS_JAR_PATH, "a", "nc", "dump", ".text", "HexText", output_hex, asm_file]
    try:
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0:
            print_error(f"Assembly failed:\n{result.stderr or result.stdout}")
            return False
        return True
    except Exception as e:
        print_error(f"Failed to run MARS: {e}")
        return False

def convert_hex_to_bin(hex_file, bin_file, big_endian=True):
    try:
        with open(hex_file, 'r') as f:
            hex_lines = [line.strip() for line in f if line.strip()]
        
        with open(bin_file, 'wb') as f:
            for line in hex_lines:
                val = int(line, 16)
                if big_endian:
                    f.write(struct.pack('>I', val))
                else:
                    f.write(struct.pack('<I', val))
        return True
    except Exception as e:
        print_error(f"Binary conversion failed: {e}")
        return False

def convert_hex_to_arduino(hex_file, h_file, array_name="program"):
    try:
        with open(hex_file, 'r') as f:
            hex_lines = [line.strip() for line in f if line.strip()]
        
        with open(h_file, 'w') as f:
            f.write(f"/* Generated by MIPSduino Assembler (MicroCoreASM) */\n")
            f.write(f"#ifndef __{array_name.upper()}_H__\n")
            f.write(f"#define __{array_name.upper()}_H__\n\n")
            f.write(f"#include <stdint.h>\n\n")
            f.write(f"const uint32_t {array_name}[] = {{\n")
            for i, line in enumerate(hex_lines):
                comma = "," if i < len(hex_lines) - 1 else ""
                f.write(f"    0x{line}{comma}\n")
            f.write(f"}};\n\n")
            f.write(f"const uint32_t {array_name}_len = {len(hex_lines)};\n\n")
            f.write(f"#endif\n")
        return True
    except Exception as e:
        print_error(f"Arduino header conversion failed: {e}")
        return False

def get_symbol_table(asm_file):
    # Standard MIPS memory layout
    DATA_START = 0x10010000
    TEXT_START = 0x00400000
    
    symbols = {'data': [], 'text': []}
    current_segment = '.text'
    data_offset = 0
    text_offset = 0
    
    if not os.path.exists(asm_file):
        return None

    with open(asm_file, 'r') as f:
        for line_num, line in enumerate(f, 1):
            line = line.strip()
            if not line or line.startswith('#'): continue
            
            # Track segment
            if line.startswith('.data'):
                current_segment = 'data'
                continue
            elif line.startswith('.text'):
                current_segment = 'text'
                continue
            
            # Find labels
            label_match = re.match(r'^([a-zA-Z_][a-zA-Z0-9_]*):\s*(.*)', line)
            if label_match:
                label = label_match.group(1)
                rest = label_match.group(2).strip()
                
                if current_segment == 'data':
                    address = DATA_START + data_offset
                    symbols['data'].append({'label': label, 'address': address, 'line': line_num})
                    # Basic size estimation
                    if '.word' in rest: data_offset += len(rest.split('.word')[1].split(',')) * 4
                    elif '.half' in rest: data_offset += len(rest.split('.half')[1].split(',')) * 2
                    elif '.byte' in rest: data_offset += len(rest.split('.byte')[1].split(','))
                    elif '.space' in rest: 
                        try: data_offset += int(re.search(r'\.space\s+(\d+)', rest).group(1))
                        except: pass
                    elif '.asciiz' in rest or '.ascii' in rest:
                        match = re.search(r'"([^"]*)"', rest)
                        if match: 
                            slen = len(match.group(1)) + (1 if '.asciiz' in rest else 0)
                            data_offset += ((slen + 3) // 4) * 4
                else:
                    address = TEXT_START + text_offset
                    symbols['text'].append({'label': label, 'address': address, 'line': line_num})
                    if rest: text_offset += 4
            elif current_segment == 'text' and not line.startswith('.'):
                text_offset += 4
    return symbols

# --- Commands ---

def cmd_build(args):
    print_info(f"Building for MicroCoreASM: {args.file}...")
    
    base_name = os.path.splitext(args.file)[0]
    output_hex = args.output if args.output and args.output.endswith('.hex') else base_name + ".hex"
    
    if not assemble_to_hex(args.file, output_hex):
        return

    print_success(f"Assembled to {output_hex}")

    if args.format == 'bin':
        output_bin = args.output if args.output and args.output.endswith('.bin') else base_name + ".bin"
        if convert_hex_to_bin(output_hex, output_bin):
            print_success(f"Generated: {output_bin}")
    elif args.format == 'arduino':
        output_h = args.output if args.output and args.output.endswith('.h') else base_name + ".h"
        if convert_hex_to_arduino(output_hex, output_h):
            print_success(f"Generated: {output_h}")
    elif args.format == 'all':
        convert_hex_to_bin(output_hex, base_name + ".bin")
        convert_hex_to_arduino(output_hex, base_name + ".h")
        print_success(f"Generated: {base_name}.bin")
        print_success(f"Generated: {base_name}.h")
        print_info("Generated all formats (hex, bin, h) by default.")

def cmd_run(args):
    if not check_java():
        print_error("Java not found. Please install JRE 8+.")
        return

    cmd = ["java", "-jar", MARS_JAR_PATH, "nc"]
    if args.no_gui:
        print()
        print_info("Launching CLI...")
    cmd.append(args.file)
    try:
        subprocess.run(cmd)
    except KeyboardInterrupt:
        print("\nInterrupted by user.")

def cmd_upload(args):
    try:
        import serial
    except ImportError:
        print_error("pyserial not found. Please install it with: pip install pyserial")
        return

    print_banner()
    print_info(f"Uploading {os.path.basename(args.file)} to {args.port} at {args.baud} baud...")
    
    # In a real scenario, we would first build the file to get the binary
    # For now, let's assume we upload the .bin file if it exists, or build it first.
    bin_path = args.file.replace('.asm', '.bin')
    if not os.path.exists(bin_path):
        print_info("Binary not found, building first...")
        # Call build logic directly
        class DummyArgs:
            def __init__(self, file):
                self.file = file
                self.output = None
                self.format = 'bin'
        cmd_build(DummyArgs(args.file))

    if not os.path.exists(bin_path):
        print_error("Failed to generate binary for upload.")
        return

    try:
        with open(bin_path, 'rb') as f:
            data = f.read()
        
        # Serial upload logic
        ser = serial.Serial(args.port, args.baud, timeout=1)
        ser.write(data)
        ser.close()
        
        print_success("Upload complete!")
    except Exception as e:
        print_error(f"Upload failed: {str(e)}")

def cmd_symbols(args):
    symbols = get_symbol_table(args.file)
    if not symbols:
        print_error("Could not parse symbols.")
        return

    print(f"\n{Colors.BOLD}Symbol Table for {args.file}{Colors.ENDC}")
    print("=" * 50)
    
    print(f"\n{Colors.CYAN}Data Segment:{Colors.ENDC}")
    print(f"{'Label':<20} {'Address':<12} {'Line'}")
    print("-" * 45)
    for s in symbols['data']:
        print(f"{s['label']:<20} 0x{s['address']:08x}   {s['line']}")
    if not symbols['data']: print("  (None)")

    print(f"\n{Colors.CYAN}Text Segment:{Colors.ENDC}")
    print(f"{'Label':<20} {'Address':<12} {'Line'}")
    print("-" * 45)
    for s in symbols['text']:
        print(f"{s['label']:<20} 0x{s['address']:08x}   {s['line']}")
    if not symbols['text']: print("  (None)")
    print()

def cmd_memory(args):
    if not check_java(): return
    if not os.environ.get("MIPSX_NO_BANNER"):
        print_banner()
    print_info(f"Dumping memory for {os.path.basename(args.file)}...")
    
    # Use MARS to dump memory
    # .text segment starts at 0x00400000
    # .data segment starts at 0x10010000
    temp_text_file = "temp_text_dump.txt"
    temp_data_file = "temp_data_dump.txt"

    # Dump .text segment
    cmd_text = ["java", "-jar", MARS_JAR_PATH, "nc", "a", "dump", ".text", "HexText", temp_text_file, args.file]
    subprocess.run(cmd_text, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    
    if os.path.exists(temp_text_file):
        print(f"\n{Colors.CYAN}Memory Map (Text Segment):{Colors.ENDC}")
        print(f"{'Address':<12} {'Instruction (Hex)':<20}")
        print("-" * 35)
        with open(temp_text_file, "r") as f:
            addr = 0x00400000
            for line in f:
                print(f"0x{addr:08x}   {line.strip()}")
                addr += 4
        os.remove(temp_text_file)
    else:
        print_error("Failed to dump text segment memory. Ensure the code is valid.")

    # Dump .data segment
    cmd_data = ["java", "-jar", MARS_JAR_PATH, "nc", "a", "dump", ".data", "HexText", temp_data_file, args.file]
    subprocess.run(cmd_data, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    if os.path.exists(temp_data_file):
        print(f"\n{Colors.CYAN}Memory Map (Data Segment):{Colors.ENDC}")
        print(f"{'Address':<12} {'Value (Hex)':<20}")
        print("-" * 35)
        with open(temp_data_file, "r") as f:
            addr = 0x10010000
            for line in f:
                print(f"0x{addr:08x}   {line.strip()}")
                addr += 4 # Assuming .word data
        os.remove(temp_data_file)
    else:
        print_info("No data segment memory dumped or data segment is empty.")


def cmd_registers(args):
    if not check_java(): return
    if not os.environ.get("MIPSX_NO_BANNER"):
        print_banner()
    print_info(f"Dumping registers for {os.path.basename(args.file)}...")
    
    temp_reg_file = "temp_reg_dump.txt"
    # Run MARS to assemble, execute, and then dump registers
    # The 'a' command assembles and runs. Then 'dump .reg' dumps all registers.
    cmd = ["java", "-jar", MARS_JAR_PATH, "nc", "a", args.file, "dump", ".reg", "HexText", temp_reg_file]
    subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    if os.path.exists(temp_reg_file):
        print(f"\n{Colors.CYAN}Register States (after execution):{Colors.ENDC}")
        print(f"{'Register':<10} {'Value (Hex)':<12}")
        print("-" * 25)
        with open(temp_reg_file, "r") as f:
            for line in f:
                parts = line.strip().split()
                if len(parts) == 2:
                    reg_name = parts[0]
                    reg_value = parts[1]
                    print(f"{reg_name:<10} {reg_value:<12}")
        os.remove(temp_reg_file)
    else:
        print_error("Failed to dump registers. Ensure the code is valid.")
    print()

def cmd_interactive():
    while True:
        print(f"\n{Colors.BOLD}{Colors.BLUE}--- Interactive Menu ---{Colors.ENDC}")
        print(f"{Colors.CYAN}[1]{Colors.ENDC} Run MIPS File (CLI)")
        print(f"{Colors.CYAN}[2]{Colors.ENDC} Build for MicroCoreASM (Bin, Arduino, Hex)")
        print(f"{Colors.CYAN}[3]{Colors.ENDC} View Symbol Table & Addresses")
        print(f"{Colors.CYAN}[4]{Colors.ENDC} Launch MARS GUI")
        print(f"{Colors.CYAN}[q]{Colors.ENDC} Quit")
        
        choice = input(f"\n{Colors.BOLD}Select an option: {Colors.ENDC}").strip().lower()
        
        if choice == 'q':
            print_info("Goodbye!")
            break
        
        if choice in ['1', '2', '3', '4']:
            asm_file = input(f"{Colors.BOLD}Enter .asm file path: {Colors.ENDC}").strip()
            if not os.path.exists(asm_file):
                print_error(f"File '{asm_file}' not found.")
                continue
            
            class Args: pass
            args = Args()
            args.file = asm_file
            
            if choice == '1':
                args.no_gui = True
                cmd_run(args)
            elif choice == '2':
                args.format = 'all'
                args.output = None
                cmd_build(args)
            elif choice == '3':
                cmd_symbols(args)
            elif choice == '4':
                args.no_gui = False
                cmd_run(args)
        else:
            print_warning("Invalid choice. Please try again.")

def main():
    parser = argparse.ArgumentParser(description="MIPSduino Assembler - MicroCoreASM Toolchain")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Build
    build_p = subparsers.add_parser("build", help="Assemble and export")
    build_p.add_argument("file", help="Input .asm file")
    build_p.add_argument("-o", "--output", help="Output file path")
    build_p.add_argument("-f", "--format", choices=['hex', 'bin', 'arduino', 'all'], default='all', 
                         help="Output format (default: all)")

    # Run
    run_p = subparsers.add_parser("run", help="Run assembly file")
    run_p.add_argument("file", help="Input .asm file")
    run_p.add_argument("--no-gui", action="store_true", help="Run in CLI mode")

    # Symbols
    sym_p = subparsers.add_parser("symbols", help="Show symbol table and addresses")
    sym_p.add_argument("file", help="Input .asm file")

    # Memory
    mem_p = subparsers.add_parser("memory", help="Dump memory map")
    mem_p.add_argument("file", help="Input .asm file")

    # Registers
    reg_p = subparsers.add_parser("registers", help="Dump register states")
    reg_p.add_argument("file", help="Input .asm file")

    # Upload
    upload_p = subparsers.add_parser("upload", help="Upload binary to hardware")
    upload_p.add_argument("file", help="Input .asm file")
    upload_p.add_argument("--port", default="COM3", help="Serial port")
    upload_p.add_argument("--baud", type=int, default=9600, help="Baud rate")

    # GUI
    gui_p = subparsers.add_parser("gui", help="Open MARS GUI")
    gui_p.add_argument("file", nargs='?', help="Optional .asm file to open")

    # Interactive
    subparsers.add_parser("menu", help="Launch interactive menu")

    if len(sys.argv) == 1:
        cmd_interactive()
        return

    args = parser.parse_args()

    if not os.environ.get("MIPSX_NO_BANNER"):
        print_banner()

    if args.command == "build":
        cmd_build(args)
    elif args.command == "run":
        cmd_run(args)
    elif args.command == "symbols":
        print_banner()
        cmd_symbols(args)
    elif args.command == "memory":
        cmd_memory(args)
    elif args.command == "registers":
        cmd_registers(args)
    elif args.command == "upload":
        cmd_upload(args)
    elif args.command == "gui":
        args.no_gui = False
        cmd_run(args)
    elif args.command == "menu":
        cmd_interactive()
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
