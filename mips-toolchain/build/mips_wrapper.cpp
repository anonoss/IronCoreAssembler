#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <regex>
#include <filesystem>
#include <windows.h>

namespace fs = std::filesystem;

// --- UI Helpers ---
struct Colors {
    static const std::string HEADER;
    static const std::string BLUE;
    static const std::string CYAN;
    static const std::string GREEN;
    static const std::string YELLOW;
    static const std::string RED;
    static const std::string ENDC;
    static const std::string BOLD;
};

const std::string Colors::HEADER = "";
const std::string Colors::BLUE = "";
const std::string Colors::CYAN = "";
const std::string Colors::GREEN = "";
const std::string Colors::YELLOW = "";
const std::string Colors::RED = "";
const std::string Colors::ENDC = "";
const std::string Colors::BOLD = "";

void print_banner() {
    std::cout << "\n"
              << "    ___                      ______                \n"
              << "   /  _/________  ____      / ____/___  ________  \n"
              << "   / / / ___/ __ \\/ __ \\    / /   / __ \\/ ___/ _ \\ \n"
              << " _/ / / /  / /_/ / / / /   / /___/ /_/ / /  /  __/ \n"
              << "/___/_/   \\____/_/ /_/____ \\____/\\____/_/   \\___/  \n"
              << "                    /_____/                        \n"
              << "    MIPS-X Toolchain | IronCore Assembler v2.0\n"
              << "    All copyright owned by Anon Open Source\n\n";
}

void print_success(const std::string& msg) {
    std::cout << "[OK] " << msg << std::endl;
}

void print_error(const std::string& msg) {
    std::cerr << "[ERROR] " << msg << std::endl;
}

void print_info(const std::string& msg) {
    std::cout << "[INFO] " << msg << std::endl;
}

void print_warning(const std::string& msg) {
    std::cout << "[WARN] " << msg << std::endl;
}

// --- Configuration ---
std::string get_mars_jar_path() {
    if (fs::exists("Mars.jar")) return "Mars.jar";
    if (fs::exists("../Mars.jar")) return "../Mars.jar";
    if (fs::exists("../../Mars.jar")) return "../../Mars.jar";
    return "Mars.jar";
}

bool check_java() {
    return std::system("java -version > nul 2>&1") == 0;
}

// --- Core Logic ---

bool assemble_to_hex(const std::string& asm_file, const std::string& output_hex) {
    std::string mars_path = get_mars_jar_path();
    if (!fs::exists(mars_path)) {
        print_error("Mars.jar not found.");
        return false;
    }

    std::string cmd = "java -jar " + mars_path + " a nc dump .text HexText " + output_hex + " " + asm_file;
    return std::system(cmd.c_str()) == 0;
}

bool convert_hex_to_bin(const std::string& hex_file, const std::string& bin_file) {
    std::ifstream infile(hex_file);
    if (!infile.is_open()) return false;

    std::ofstream outfile(bin_file, std::ios::binary);
    if (!outfile.is_open()) return false;

    std::string line;
    while (std::getline(infile, line)) {
        if (line.empty()) continue;
        unsigned int val = std::stoul(line, nullptr, 16);
        unsigned char bytes[4];
        bytes[0] = (val >> 24) & 0xFF;
        bytes[1] = (val >> 16) & 0xFF;
        bytes[2] = (val >> 8) & 0xFF;
        bytes[3] = val & 0xFF;
        outfile.write((char*)bytes, 4);
    }
    return true;
}

bool convert_hex_to_arduino(const std::string& hex_file, const std::string& h_file, const std::string& array_name = "program") {
    std::ifstream infile(hex_file);
    if (!infile.is_open()) return false;

    std::ofstream outfile(h_file);
    if (!outfile.is_open()) return false;

    std::vector<std::string> hex_lines;
    std::string line;
    while (std::getline(infile, line)) {
        if (!line.empty()) hex_lines.push_back(line);
    }

    outfile << "/* Generated by IronCore MIPS-X Toolchain */\n";
    outfile << "#ifndef __" << array_name << "_H__\n";
    outfile << "#define __" << array_name << "_H__\n\n";
    outfile << "#include <stdint.h>\n\n";
    outfile << "const uint32_t " << array_name << "[] = {\n";
    for (size_t i = 0; i < hex_lines.size(); ++i) {
        outfile << "    0x" << hex_lines[i] << (i < hex_lines.size() - 1 ? "," : "") << "\n";
    }
    outfile << "};\n\n";
    outfile << "const uint32_t " << array_name << "_len = " << hex_lines.size() << ";\n\n";
    outfile << "#endif\n";
    return true;
}

void cmd_symbols(const std::string& asm_file) {
    std::ifstream infile(asm_file);
    if (!infile.is_open()) {
        print_error("Could not open file.");
        return;
    }

    std::cout << "\nSymbol Table for " << asm_file << "\n";
    std::cout << "==================================================\n";
    
    std::string line;
    std::string current_segment = ".text";
    unsigned int text_addr = 0x00400000;
    unsigned int data_addr = 0x10010000;
    
    std::regex label_regex("^([a-zA-Z_][a-zA-Z0-9_]*):");
    
    while (std::getline(infile, line)) {
        line.erase(0, line.find_first_not_of(" \t"));
        if (line.empty() || line[0] == '#') continue;
        
        if (line.find(".data") == 0) { current_segment = ".data"; continue; }
        if (line.find(".text") == 0) { current_segment = ".text"; continue; }
        
        std::smatch match;
        if (std::regex_search(line, match, label_regex)) {
            std::string label = match[1];
            unsigned int addr = (current_segment == ".text") ? text_addr : data_addr;
            printf("%-20s 0x%08x\n", label.c_str(), addr);
        }
        
        if (current_segment == ".text" && line.find(".") != 0) {
            text_addr += 4;
        }
    }
}

int main(int argc, char* argv[]) {
    print_banner();

    if (argc < 2) {
        std::cout << "Usage: mips <command> [args]\n";
        std::cout << "Commands: build, run, symbols, gui\n";
        return 0;
    }

    std::string cmd = argv[1];

    if (cmd == "build" && argc >= 3) {
        std::string file = argv[2];
        std::string base = file.substr(0, file.find_last_of("."));
        if (assemble_to_hex(file, base + ".hex")) {
            print_success("Assembled to " + base + ".hex");
            // Check for format flags
            for (int i = 3; i < argc; ++i) {
                std::string arg = argv[i];
                if (arg == "-f" && i + 1 < argc) {
                    std::string fmt = argv[i+1];
                    if (fmt == "bin" || fmt == "all") {
                        convert_hex_to_bin(base + ".hex", base + ".bin");
                        print_success("Generated " + base + ".bin");
                    }
                    if (fmt == "arduino" || fmt == "all") {
                        convert_hex_to_arduino(base + ".hex", base + ".h");
                        print_success("Generated " + base + ".h");
                    }
                }
            }
        }
    } else if (cmd == "run" && argc >= 3) {
        std::string mars_path = get_mars_jar_path();
        std::string run_cmd = "java -jar " + mars_path + " nc " + argv[2];
        std::system(run_cmd.c_str());
    } else if (cmd == "gui") {
        std::string mars_path = get_mars_jar_path();
        std::string gui_cmd = "java -jar " + mars_path + (argc >= 3 ? (std::string(" ") + argv[2]) : "");
        std::system(gui_cmd.c_str());
    } else if (cmd == "symbols" && argc >= 3) {
        cmd_symbols(argv[2]);
    } else {
        std::cout << "Unknown command or missing arguments.\n";
    }

    return 0;
}
