#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <regex>
#include <filesystem>
#include <windows.h>

namespace fs = std::filesystem;

// --- UI Helpers ---
struct Colors {
    static const std::string HEADER;
    static const std::string BLUE;
    static const std::string CYAN;
    static const std::string GREEN;
    static const std::string YELLOW;
    static const std::string RED;
    static const std::string ENDC;
    static const std::string BOLD;
};

const std::string Colors::HEADER = "";
const std::string Colors::BLUE = "";
const std::string Colors::CYAN = "";
const std::string Colors::GREEN = "";
const std::string Colors::YELLOW = "";
const std::string Colors::RED = "";
const std::string Colors::ENDC = "";
const std::string Colors::BOLD = "";

void print_banner() {
    std::cout << "\n"
              << "    ___                      ______                \n"
              << "   /  _/________  ____      / ____/___  ________  \n"
              << "   / / / ___/ __ \\/ __ \\    / /   / __ \\/ ___/ _ \\ \n"
              << " _/ / / /  / /_/ / / / /   / /___/ /_/ / /  /  __/ \n"
              << "/___/_/   \\____/_/ /_/____ \\____/\\____/_/   \\___/  \n"
              << "                    /_____/                        \n"
              << "    MIPSduino Assembler v2.0\n"
              << "    Powered by MicroCoreASM Hardware Integration\n\n";
}

void print_success(const std::string& msg) {
    std::cout << "[OK] " << msg << std::endl;
}

void print_error(const std::string& msg) {
    std::cerr << "[ERROR] " << msg << std::endl;
}

void print_info(const std::string& msg) {
    std::cout << "[INFO] " << msg << std::endl;
}

void print_warning(const std::string& msg) {
    std::cout << "[WARN] " << msg << std::endl;
}

void wait_for_exit() {
    std::cout << "\nPress Enter to exit...";
    std::cin.clear();
    std::cin.ignore(10000, '\n');
    std::cin.get();
}

// --- Configuration ---
std::string get_mars_jar_path() {
    if (fs::exists("Mars.jar")) return "Mars.jar";
    if (fs::exists("../Mars.jar")) return "../Mars.jar";
    if (fs::exists("../../Mars.jar")) return "../../Mars.jar";
    
    // Check in the same directory as the executable
    char path[MAX_PATH];
    GetModuleFileNameA(NULL, path, MAX_PATH);
    std::string exe_dir = fs::path(path).parent_path().string();
    std::string local_mars = exe_dir + "\\Mars.jar";
    if (fs::exists(local_mars)) return local_mars;

    return "Mars.jar";
}

bool check_java() {
    return std::system("java -version > nul 2>&1") == 0;
}

// --- Core Logic ---

bool assemble_to_hex(const std::string& asm_file, const std::string& output_hex) {
    std::string mars_path = get_mars_jar_path();
    if (!fs::exists(mars_path)) {
        print_error("Mars.jar not found. Please ensure Mars.jar is in the same folder as this program.");
        return false;
    }

    std::string cmd = "java -jar \"" + mars_path + "\" a nc dump .text HexText \"" + output_hex + "\" \"" + asm_file + "\"";
    return std::system(cmd.c_str()) == 0;
}

bool convert_hex_to_bin(const std::string& hex_file, const std::string& bin_file) {
    std::ifstream infile(hex_file);
    if (!infile.is_open()) return false;

    std::ofstream outfile(bin_file, std::ios::binary);
    if (!outfile.is_open()) return false;

    std::string line;
    while (std::getline(infile, line)) {
        if (line.empty()) continue;
        try {
            unsigned int val = std::stoul(line, nullptr, 16);
            unsigned char bytes[4];
            bytes[0] = (val >> 24) & 0xFF;
            bytes[1] = (val >> 16) & 0xFF;
            bytes[2] = (val >> 8) & 0xFF;
            bytes[3] = val & 0xFF;
            outfile.write((char*)bytes, 4);
        } catch (...) { continue; }
    }
    return true;
}

bool convert_hex_to_arduino(const std::string& hex_file, const std::string& h_file, const std::string& array_name = "program") {
    std::ifstream infile(hex_file);
    if (!infile.is_open()) return false;

    std::ofstream outfile(h_file);
    if (!outfile.is_open()) return false;

    std::vector<std::string> hex_lines;
    std::string line;
    while (std::getline(infile, line)) {
        if (!line.empty()) hex_lines.push_back(line);
    }

    outfile << "/* Generated by MIPSduino Assembler (MicroCoreASM) */\n";
    outfile << "#ifndef __" << array_name << "_H__\n";
    outfile << "#define __" << array_name << "_H__\n\n";
    outfile << "#include <stdint.h>\n\n";
    outfile << "const uint32_t " << array_name << "[] = {\n";
    for (size_t i = 0; i < hex_lines.size(); ++i) {
        outfile << "    0x" << hex_lines[i] << (i < hex_lines.size() - 1 ? "," : "") << "\n";
    }
    outfile << "};\n\n";
    outfile << "const uint32_t " << array_name << "_len = " << hex_lines.size() << ";\n\n";
    outfile << "#endif\n";
    return true;
}

void cmd_symbols(const std::string& asm_file) {
    if (!fs::exists(asm_file)) {
        print_error("File not found: " + asm_file);
        return;
    }
    std::ifstream infile(asm_file);
    if (!infile.is_open()) {
        print_error("Could not open file.");
        return;
    }

    std::cout << "\nSymbol Table for " << asm_file << "\n";
    std::cout << "==================================================\n";
    
    std::string line;
    std::string current_segment = ".text";
    unsigned int text_addr = 0x00400000;
    unsigned int data_addr = 0x10010000;
    
    std::regex label_regex("^([a-zA-Z_][a-zA-Z0-9_]*):");
    
    while (std::getline(infile, line)) {
        line.erase(0, line.find_first_not_of(" \t"));
        if (line.empty() || line[0] == '#') continue;
        
        if (line.find(".data") == 0) { current_segment = ".data"; continue; }
        if (line.find(".text") == 0) { current_segment = ".text"; continue; }
        
        std::smatch match;
        if (std::regex_search(line, match, label_regex)) {
            std::string label = match[1];
            unsigned int addr = (current_segment == ".text") ? text_addr : data_addr;
            printf("%-20s 0x%08x\n", label.c_str(), addr);
        }
        
        if (current_segment == ".text" && line.find(".") != 0) {
            text_addr += 4;
        }
    }
}

void show_menu() {
    while (true) {
        std::cout << "\n--- MIPSduino Interactive Menu ---\n";
        std::cout << "1. Build MIPS (.asm -> .hex, .bin, .h)\n";
        std::cout << "2. Run MIPS (CLI Mode)\n";
        std::cout << "3. Launch MARS GUI\n";
        std::cout << "4. View Symbol Table\n";
        std::cout << "5. Exit\n";
        std::cout << "\nSelect an option: ";

        int choice;
        if (!(std::cin >> choice)) {
            std::cin.clear();
            std::cin.ignore(10000, '\n');
            continue;
        }

        if (choice == 5) break;

        std::string file;
        if (choice != 3) {
            std::cout << "Enter .asm file path: ";
            std::cin >> file;
        }

        if (choice == 1) {
            std::string base = file.substr(0, file.find_last_of("."));
            if (assemble_to_hex(file, base + ".hex")) {
                print_success("Generated " + base + ".hex");
                convert_hex_to_bin(base + ".hex", base + ".bin");
                print_success("Generated " + base + ".bin");
                convert_hex_to_arduino(base + ".hex", base + ".h");
                print_success("Generated " + base + ".h");
            }
        } else if (choice == 2) {
            std::string mars_path = get_mars_jar_path();
            std::string run_cmd = "java -jar \"" + mars_path + "\" nc \"" + file + "\"";
            std::system(run_cmd.c_str());
        } else if (choice == 3) {
            std::string mars_path = get_mars_jar_path();
            std::string gui_cmd = "java -jar \"" + mars_path + "\"";
            std::system(gui_cmd.c_str());
        } else if (choice == 4) {
            cmd_symbols(file);
        }
    }
}

void show_help() {
    std::cout << "MIPSduino Assembler v2.0.0 (MicroCoreASM)\n";
    std::cout << "Usage: MIPSduino <command> [options] <file>\n\n";
    std::cout << "Commands:\n";
    std::cout << "  build <file>    Assemble .asm to .hex, .bin, and .h\n";
    std::cout << "  run <file>      Execute MIPS code in CLI mode\n";
    std::cout << "  gui [file]      Open MARS GUI (optional: with file)\n";
    std::cout << "  symbols <file>  Display symbol table and addresses\n";
    std::cout << "  menu            Launch interactive menu (for beginners)\n\n";
    std::cout << "Options:\n";
    std::cout << "  -f <format>     Specify output format (hex, bin, arduino, all)\n";
    std::cout << "  -o <file>       Specify output filename\n";
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        print_banner();
        show_help();
        return 0;
    }

    std::string cmd = argv[1];

    // Check for Java first as it's a hard dependency
    if (!check_java()) {
        print_error("Java (JRE) not found! Please install Java to use this tool.");
        return 1;
    }

    if (cmd == "build" && argc >= 3) {
        std::string file = argv[2];
        std::string base = file.substr(0, file.find_last_of("."));
        if (assemble_to_hex(file, base + ".hex")) {
            print_success("Assembled: " + base + ".hex");
            
            bool format_specified = false;
            for (int i = 3; i < argc; ++i) {
                std::string arg = argv[i];
                if (arg == "-f" && i + 1 < argc) {
                    format_specified = true;
                    std::string fmt = argv[i+1];
                    if (fmt == "bin" || fmt == "all") {
                        convert_hex_to_bin(base + ".hex", base + ".bin");
                        print_success("Generated: " + base + ".bin");
                    }
                    if (fmt == "arduino" || fmt == "all") {
                        convert_hex_to_arduino(base + ".hex", base + ".h");
                        print_success("Generated: " + base + ".h");
                    }
                }
            }
            
            // Default behavior if no format specified: generate all for convenience
            if (!format_specified) {
                convert_hex_to_bin(base + ".hex", base + ".bin");
                convert_hex_to_arduino(base + ".hex", base + ".h");
                print_info("Generated all formats (hex, bin, h) by default.");
            }
        } else {
            return 1;
        }
    } else if (cmd == "run" && argc >= 3) {
        std::string mars_path = get_mars_jar_path();
        std::string run_cmd = "java -jar \"" + mars_path + "\" nc \"" + argv[2] + "\"";
        return std::system(run_cmd.c_str());
    } else if (cmd == "gui") {
        std::string mars_path = get_mars_jar_path();
        std::string gui_cmd = "java -jar \"" + mars_path + "\"" + (argc >= 3 ? (std::string(" \"") + argv[2] + "\"") : "");
        return std::system(gui_cmd.c_str());
    } else if (cmd == "symbols" && argc >= 3) {
        cmd_symbols(argv[2]);
    } else if (cmd == "menu") {
        print_banner();
        show_menu();
    } else if (cmd == "--help" || cmd == "-h") {
        show_help();
    } else {
        print_error("Unknown command: " + cmd);
        show_help();
        return 1;
    }

    return 0;
}
